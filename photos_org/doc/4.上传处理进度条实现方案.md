[9 tools called]

## 📋 **导入照片进度条跟踪具体实现方案**

经过仔细阅读代码，我已经完全理解了导入照片功能的进度条跟踪机制。

### 🔄 **两个步骤的具体实现**

#### **第一步：文件上传到服务器**
```javascript
// API: POST /api/v1/import/upload
// 前端使用XMLHttpRequest监听上传进度

const xhr = new XMLHttpRequest();

// 监听上传进度事件
xhr.upload.addEventListener('progress', (event) => {
    if (event.lengthComputable) {
        const percentComplete = Math.round((event.loaded / event.total) * 100);
        
        // 更新进度条
        elements.importProgressBar.style.width = `${percentComplete}%`;
        
        // 更新状态文本
        elements.importStatus.textContent = `正在上传 ${files.length} 个文件... ${percentComplete}%`;
    }
});

// 发送文件
xhr.open('POST', `${CONFIG.API_BASE_URL}/import/upload`);
xhr.send(formData);
```

**特点**：
- ✅ **实时字节级进度**：基于 `event.loaded / event.total`
- ✅ **浏览器原生支持**：XMLHttpRequest的progress事件
- ✅ **精确到1%**：避免频繁更新（变化≥1%才更新）

#### **第二步：上传后的后台处理**
```javascript
// API: GET /api/v1/import/scan-status/{task_id}
// 前端定时轮询状态

function monitorImportProgress(taskId, totalFiles) {
    const progressInterval = setInterval(async () => {
        const response = await fetch(`${CONFIG.API_BASE_URL}/import/scan-status/${taskId}`);
        const statusData = await response.json();
        
        // 更新进度条
        const progress = statusData.progress_percentage || 0;
        elements.importProgressBar.style.width = `${progress}%`;
        
        // 更新详细状态
        elements.importStatus.textContent = `正在处理: ${statusData.processed_files || 0}/${totalFiles} (${progress}%) - 已导入: ${statusData.imported_count || 0}, 跳过: ${statusData.skipped_count || 0}, 失败: ${statusData.failed_count || 0}`;
        
        // 检查完成
        if (statusData.status === 'completed') {
            clearInterval(progressInterval);
            showImportDetails(statusData);
        }
    }, 500); // 每500ms检查一次
}
```

### 📡 **API接口详情**

#### **1. 上传接口** (`POST /api/v1/import/upload`)
```javascript
// 后端实现
@router.post("/upload")
async def upload_photos(files: List[UploadFile] = File(...)):
    # 生成任务ID
    task_id = str(uuid.uuid4())
    
    # 添加后台任务处理
    background_tasks.add_task(
        process_photos_batch_with_status_from_upload, 
        files, db, task_id
    )
    
    # 立即返回任务ID（HTTP 202）
    return {
        "success": True,
        "data": {
            "task_id": task_id,
            "total_files": len(files)
        }
    }
```

#### **2. 状态查询接口** (`GET /api/v1/import/scan-status/{task_id}`)
```javascript
// 后端实现
@router.get("/scan-status/{task_id}")
async def get_scan_status(task_id: str):
    return task_status[task_id]  # 返回状态字典
```

#### **状态数据结构**：
```javascript
{
    "status": "processing", // 或 "completed", "failed"
    "total_files": 5,
    "processed_files": 3,
    "imported_count": 3,
    "skipped_count": 0,
    "failed_count": 0,
    "failed_files": [],
    "progress_percentage": 60
}
```

### 🔄 **后端状态更新机制**

```python
# 在后台任务中实时更新状态
async def process_photos_batch_with_status_from_upload(files, db, task_id):
    # 初始化状态
    task_status[task_id] = {
        "status": "processing",
        "progress_percentage": 0,
        # ... 其他字段
    }
    
    # 处理每个文件后更新进度
    for i, file in enumerate(files):
        # 处理文件...
        
        # 更新状态（每个文件处理完都更新）
        task_status[task_id]["processed_files"] = i + 1
        task_status[task_id]["progress_percentage"] = int((i + 1) / len(files) * 100)
        task_status[task_id]["imported_count"] = imported_count
        # ... 更新其他计数器
```

### 🎯 **进度条连续性设计**

1. **第一阶段**：上传进度 0% → 100%
2. **过渡阶段**：显示"上传完成，后台正在处理..."
3. **第二阶段**：处理进度 0% → 100%（继续使用同一进度条）

**进度条视觉效果**：
```
[████████████░░░░] 正在上传 3 个文件... 60%
[████████████████] 上传完成，后台正在处理 3 个文件...
[████████░░░░░░░░] 正在处理: 1/3 (33%) - 已导入: 1, 跳过: 0, 失败: 0
[████████████████] 正在处理: 3/3 (100%) - 已导入: 3, 跳过: 0, 失败: 0
```

### 🚀 **技术特点**

- **双重进度跟踪**：上传用浏览器事件，处理用API轮询
- **无缝衔接**：两个阶段使用同一进度条元素
- **详细状态反馈**：不仅显示百分比，还显示具体数量
- **容错设计**：网络异常、超时等都有处理逻辑
- **实时同步**：前端每500ms获取最新状态

这个实现确保了用户在整个导入过程中都能看到清晰、准确的进度反馈！ 🎉