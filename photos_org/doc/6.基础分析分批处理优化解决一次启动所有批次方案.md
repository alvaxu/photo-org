[1 tool called]

# 基础分析分批处理优化方案

## 一、当前实现问题分析

### 1.1 对比设计文档与实际代码

| 设计要求 | 设计文档规范 | 当前实现 | 状态 |
|----------|--------------|----------|------|
| 分批阈值 | `batch_threshold: 200` | `BATCH_THRESHOLD = 200` ✅ | ✅ 已实现但硬编码 |
| 批次大小 | `batch_size: 100` | `BATCH_SIZE = 100` ✅ | ✅ 已实现但硬编码 |
| 并发控制 | `max_concurrent_batches: 3` | **无并发控制** ❌ | ❌ 未实现 |
| 配置方式 | 使用config.json | 硬编码常量 ❌ | ❌ 未实现 |

### 1.2 核心问题

1. **无并发控制**：`processBasicAnalysisInBatches` 一次性启动所有批次，导致62批同时运行
2. **硬编码配置**：不使用 `config.json` 中的参数
3. **缺少 max_concurrent_batches**：无法控制同时运行的批次数
4. **资源竞争**：62个批次 + 2个线程 = 严重阻塞

## 二、优化方案设计

### 2.1 总体架构优化

```
当前架构：一次性启动 → 全部并发 → 资源耗尽
优化架构：分阶段启动 → 控制并发 → 动态扩容
```

#### 优化后的处理流程：
```
1. 读取配置参数 (concurrent, batch_size)
2. 计算总批次数
3. 首次启动 N 个批次 (N = concurrent)
4. 监控活跃批次，检测完成情况
5. 批次完成时启动新的批次补充
6. 直到所有批次都处理完成
```

### 2.2 具体优化内容

#### 2.2.1 配置参数集成
**文件**：`static/js/app-import.js`
**位置**：`startBasicProcess` 函数

**修改前**：
```javascript
const BATCH_THRESHOLD = 200;  // 分批处理阈值
const BATCH_SIZE = 100;       // 每批大小
```

**修改后**：
```javascript
// 从配置文件读取参数，支持默认值
const CONFIG = window.CONFIG || {};
const ANALYSIS_CONFIG = CONFIG.analysis || {};

const BATCH_THRESHOLD = ANALYSIS_CONFIG.batch_threshold || 200;
const BATCH_SIZE = ANALYSIS_CONFIG.batch_size || 100;
const MAX_CONCURRENT = ANALYSIS_CONFIG.concurrent || ANALYSIS_CONFIG.max_concurrent_batches || 3;
```

#### 2.2.2 并发控制逻辑重构
**核心思路**：实现真正的分阶段批次管理

**新增函数**：`processBasicAnalysisWithConcurrency`

```javascript
/**
 * 带并发控制的基础分析分批处理
 * @param {Array} photoIds - 所有需要分析的照片ID
 * @param {number} batchSize - 每批大小
 * @param {number} maxConcurrent - 最大并发批次数
 */
async function processBasicAnalysisWithConcurrency(photoIds, batchSize, maxConcurrent) {
    const totalPhotos = photoIds.length;
    const totalBatches = Math.ceil(totalPhotos / batchSize);
    
    console.log(`并发控制分批处理：${totalPhotos}张照片，分为${totalBatches}批，最多${maxConcurrent}批并发`);
    
    // 初始化状态
    const allBatchTasks = [];  // 所有批次任务信息
    const activeTasks = new Map();  // 当前活跃任务 Map<taskId, batchInfo>
    let nextBatchIndex = 0;
    
    // 准备所有批次信息
    for (let i = 0; i < totalBatches; i++) {
        const start = i * batchSize;
        const end = Math.min(start + batchSize, totalPhotos);
        const batchPhotoIds = photoIds.slice(start, end);
        
        allBatchTasks.push({
            batchIndex: i + 1,
            photoIds: batchPhotoIds,
            taskId: null,
            status: 'pending'
        });
    }
    
    // 第一阶段：启动初始并发批次
    const initialBatches = Math.min(maxConcurrent, totalBatches);
    for (let i = 0; i < initialBatches; i++) {
        await startNextBatch(allBatchTasks, activeTasks);
    }
    
    // 第二阶段：监控并动态扩容
    await monitorAndScaleConcurrentBatches(allBatchTasks, activeTasks, maxConcurrent);
}
```

#### 2.2.3 动态批次管理

**新增函数**：`monitorAndScaleConcurrentBatches`

```javascript
/**
 * 监控活跃批次并动态扩容
 */
async function monitorAndScaleConcurrentBatches(allBatchTasks, activeTasks, maxConcurrent) {
    return new Promise((resolve) => {
        const checkInterval = setInterval(async () => {
            try {
                // 1. 检查已完成的批次
                const completedTaskIds = await checkCompletedBatches(activeTasks);
                
                // 2. 从活跃列表中移除已完成的批次
                completedTaskIds.forEach(taskId => {
                    activeTasks.delete(taskId);
                });
                
                // 3. 启动新的批次补充到最大并发数
                while (activeTasks.size < maxConcurrent && hasMoreBatches(allBatchTasks)) {
                    await startNextBatch(allBatchTasks, activeTasks);
                }
                
                // 4. 检查是否全部完成
                if (activeTasks.size === 0 && !hasMoreBatches(allBatchTasks)) {
                    clearInterval(checkInterval);
                    resolve();
                }
                
            } catch (error) {
                console.error('批次监控失败:', error);
            }
        }, 1000); // 每秒检查一次
    });
}
```

#### 2.2.4 批次状态检测

**新增函数**：`checkCompletedBatches`

```javascript
/**
 * 检查并返回已完成的批次ID列表
 */
async function checkCompletedBatches(activeTasks) {
    const completedTaskIds = [];
    
    for (const [taskId, batchInfo] of activeTasks) {
        try {
            const response = await fetch(`${window.CONFIG.API_BASE_URL}/analysis/task-status/${taskId}`);
            const statusData = await response.json();
            
            if (statusData.status === 'completed') {
                completedTaskIds.push(taskId);
                console.log(`批次 ${batchInfo.batchIndex} 已完成`);
            }
        } catch (error) {
            console.warn(`检查批次 ${taskId} 状态失败:`, error);
        }
    }
    
    return completedTaskIds;
}
```

#### 2.2.5 批次启动管理

**新增函数**：`startNextBatch`

```javascript
/**
 * 启动下一个待处理的批次
 */
async function startNextBatch(allBatchTasks, activeTasks) {
    // 找到下一个待处理的批次
    const nextBatch = allBatchTasks.find(batch => batch.status === 'pending');
    if (!nextBatch) return;
    
    try {
        // 更新状态
        nextBatch.status = 'starting';
        
        // 启动批次
        const response = await fetch(`${window.CONFIG.API_BASE_URL}/analysis/start-analysis`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                photo_ids: nextBatch.photoIds,
                analysis_types: ['quality']
            })
        });
        
        if (!response.ok) {
            throw new Error(`批次 ${nextBatch.batchIndex} 启动失败`);
        }
        
        const data = await response.json();
        const taskId = data.task_id;
        
        // 更新批次信息
        nextBatch.taskId = taskId;
        nextBatch.status = 'running';
        
        // 添加到活跃任务
        activeTasks.set(taskId, {
            batchIndex: nextBatch.batchIndex,
            taskId: taskId,
            photoCount: nextBatch.photoIds.length
        });
        
        console.log(`批次 ${nextBatch.batchIndex} 已启动，任务ID: ${taskId}`);
        
    } catch (error) {
        console.error(`启动批次 ${nextBatch.batchIndex} 失败:`, error);
        nextBatch.status = 'failed';
    }
}
```

#### 2.2.6 主入口函数修改

**修改**：`startBasicProcess` 函数

```javascript
// 修改分批处理逻辑
if (photoIds.length > BATCH_THRESHOLD) {
    // 并发控制分批处理
    console.log(`基础分析并发分批处理：${photoIds.length}张照片超过阈值${BATCH_THRESHOLD}`);
    console.log(`配置参数：批次大小=${BATCH_SIZE}, 最大并发=${MAX_CONCURRENT}`);
    
    await processBasicAnalysisWithConcurrency(photoIds, BATCH_SIZE, MAX_CONCURRENT);
} else {
    // 单批处理（保持现有逻辑）
    console.log(`基础分析单批处理：${photoIds.length}张照片，使用传统单批处理`);
    await processBasicAnalysisSingleBatch(photoIds);
}
```

## 三、优化效果预期

### 3.1 性能提升

| 场景 | 原方案 | 优化方案 | 提升 |
|------|--------|----------|------|
| 6200张照片 | 62批同时运行 | 最多3批并发 | 稳定性大幅提升 |
| 处理时间 | 可能超时 | 稳定完成 | 可靠性100% |
| 内存使用 | 突发高峰 | 平滑分布 | 系统负载均衡 |
| 用户体验 | "连不到服务器" | 流畅进度显示 | 体验显著改善 |

### 3.2 配置灵活性

```json
// config.json - 可灵活调整
{
  "analysis": {
    "batch_threshold": 200,    // 超过多少张开始分批
    "batch_size": 100,         // 每批多少张
    "concurrent": 3            // 最多几批并发
  }
}
```

### 3.3 错误处理优化

1. **批次级容错**：单个批次失败不影响其他批次
2. **动态恢复**：失败批次可标记后重试
3. **状态追踪**：详细记录每个批次的状态和进度

## 四、实施计划

### 4.1 第一阶段：核心并发控制
1. 实现 `processBasicAnalysisWithConcurrency` 函数
2. 实现 `monitorAndScaleConcurrentBatches` 函数
3. 测试基本的并发启动和监控逻辑

### 4.2 第二阶段：状态管理和错误处理
1. 实现 `checkCompletedBatches` 和 `startNextBatch` 函数
2. 添加批次级别的错误处理和重试机制
3. 完善状态追踪和日志记录

### 4.3 第三阶段：配置集成和优化
1. 集成 `config.json` 参数读取
2. 优化进度显示和用户反馈
3. 性能测试和调优

### 4.4 第四阶段：测试和部署
1. 功能测试：各种边界情况
2. 性能测试：大批量处理场景
3. 灰度发布和监控

## 五、风险控制

### 5.1 技术风险
1. **状态同步**：确保批次状态准确同步
2. **内存管理**：防止批次间内存泄漏
3. **网络超时**：处理前端网络请求超时

### 5.2 业务风险
1. **向后兼容**：保持现有单批处理的兼容性
2. **用户体验**：确保进度显示清晰准确
3. **错误恢复**：提供失败批次的重新处理机制

这个优化方案将彻底解决当前"一次性启动所有批次导致服务器阻塞"的问题，实现真正的并发控制和资源管理。🚀