# 家庭版智能照片系统 - 存储管理模块详细设计文档

## 一、文档基础信息

| 项目名称 | 家庭版智能照片系统 | 文档类型 | 存储管理模块详细设计文档 |
| -------- | ------------------------- | -------- | ----------------------- |
| 文档版本 | V1.0 | 文档状态 | ☑ 草稿 □ 评审中 □ 已确认 □ 已归档 |
| 编写人 | AI助手 | 编写日期 | 2025年9月9日 |
| 关联文档 | 《家庭版简要设计文档》《数据库设计文档》《数据需求分析》 | | |

## 二、模块概述

### 2.1 模块目标

存储管理模块是家庭照片系统的文件存储核心，负责照片文件、缩略图、数据库的存储组织和管理。通过合理的目录结构、文件命名规则和存储策略，确保照片数据的安全、完整和高效访问。

### 2.2 设计原则

- **简单可靠**：存储结构简单清晰，易于管理和维护
- **空间高效**：合理组织文件，节省存储空间
- **数据安全**：确保文件完整性，防止数据丢失
- **访问高效**：快速的文件定位和访问
- **备份便捷**：便于数据备份和恢复

### 2.3 技术选型

- **文件系统**：本地文件系统，按年月日组织
- **数据库**：SQLite，单文件存储
- **备份策略**：定期备份，增量+全量结合
- **压缩算法**：ZIP压缩，减少备份文件大小

## 三、存储架构设计

### 3.1 目录结构设计

#### 3.1.1 主存储目录
```
photos_storage/
├── originals/           # 原始照片存储
│   ├── 2023/
│   │   ├── 01/
│   │   │   ├── 01/     # 按年月日组织
│   │   │   │   ├── IMG_001.jpg
│   │   │   │   └── IMG_002.jpg
│   │   │   └── 02/
│   │   └── 02/
│   └── 2024/
├── thumbnails/          # 缩略图存储
│   ├── 2023/
│   │   ├── 01/
│   │   └── 02/
│   └── 2024/
├── temp/               # 临时文件
│   ├── processing/     # 处理中文件
│   ├── uploads/        # 上传临时文件
│   └── cache/          # 缓存文件
├── backups/            # 备份文件
│   ├── daily/          # 每日备份
│   ├── weekly/         # 每周备份
│   └── monthly/        # 每月备份
└── logs/               # 日志文件
```

#### 3.1.2 数据库文件位置
```
photos_storage/
├── photos.db           # 主数据库文件
├── photos.db-journal   # SQLite事务日志
├── photos.db-shm       # SQLite共享内存
└── photos.db-wal       # SQLite预写日志
```

### 3.2 文件命名规则

#### 3.2.1 原始照片命名
```python
def generate_photo_filename(taken_at: datetime, original_name: str) -> str:
    """
    生成照片文件名
    格式：YYYYMMDD_HHMMSS_original_name.jpg
    
    :param taken_at: 拍摄时间
    :param original_name: 原始文件名
    :return: 新文件名
    """
    timestamp = taken_at.strftime('%Y%m%d_%H%M%S')
    return f"{timestamp}_{original_name}"
```

#### 3.2.2 缩略图命名
```python
def generate_thumbnail_filename(photo_id: int, original_filename: str) -> str:
    """
    生成缩略图文件名
    格式：photo_id_original_name_thumb.jpg
    
    :param photo_id: 照片ID
    :param original_filename: 原始文件名
    :return: 缩略图文件名
    """
    name_without_ext = original_filename.rsplit('.', 1)[0]
    return f"{photo_id}_{name_without_ext}_thumb.jpg"
```

## 四、存储管理功能

### 4.1 文件存储管理

#### 4.1.1 文件存储策略
```python
class FileStorageManager:
    """文件存储管理器"""
    
    def __init__(self, base_path: str):
        self.base_path = base_path
        self.originals_path = os.path.join(base_path, 'originals')
        self.thumbnails_path = os.path.join(base_path, 'thumbnails')
        self.temp_path = os.path.join(base_path, 'temp')
        
    def store_photo(self, file_data: bytes, filename: str, taken_at: datetime) -> str:
        """
        存储照片文件
        
        :param file_data: 文件数据
        :param filename: 原始文件名
        :param taken_at: 拍摄时间
        :return: 存储路径
        """
        # 生成新文件名
        new_filename = self._generate_filename(taken_at, filename)
        
        # 创建目录
        dir_path = self._get_photo_directory(taken_at)
        os.makedirs(dir_path, exist_ok=True)
        
        # 保存文件
        file_path = os.path.join(dir_path, new_filename)
        with open(file_path, 'wb') as f:
            f.write(file_data)
            
        return file_path
    
    def _generate_filename(self, taken_at: datetime, original_name: str) -> str:
        """生成文件名"""
        timestamp = taken_at.strftime('%Y%m%d_%H%M%S')
        return f"{timestamp}_{original_name}"
    
    def _get_photo_directory(self, taken_at: datetime) -> str:
        """获取照片存储目录"""
        year = taken_at.strftime('%Y')
        month = taken_at.strftime('%m')
        day = taken_at.strftime('%d')
        return os.path.join(self.originals_path, year, month, day)
```

#### 4.1.2 缩略图管理
```python
class ThumbnailManager:
    """缩略图管理器"""
    
    def __init__(self, base_path: str):
        self.base_path = base_path
        self.thumbnails_path = os.path.join(base_path, 'thumbnails')
        self.thumbnail_size = (300, 300)
        self.quality = 85
        
    def generate_thumbnail(self, photo_path: str, photo_id: int) -> str:
        """
        生成缩略图
        
        :param photo_path: 原始照片路径
        :param photo_id: 照片ID
        :return: 缩略图路径
        """
        try:
            # 打开原始照片
            with Image.open(photo_path) as img:
                # 创建缩略图
                img.thumbnail(self.thumbnail_size, Image.Resampling.LANCZOS)
                
                # 转换为RGB模式
                if img.mode != 'RGB':
                    img = img.convert('RGB')
                
                # 生成缩略图文件名
                original_name = os.path.basename(photo_path)
                thumbnail_name = self._generate_thumbnail_name(photo_id, original_name)
                
                # 创建缩略图目录
                thumbnail_dir = self._get_thumbnail_directory(photo_path)
                os.makedirs(thumbnail_dir, exist_ok=True)
                
                # 保存缩略图
                thumbnail_path = os.path.join(thumbnail_dir, thumbnail_name)
                img.save(thumbnail_path, 'JPEG', quality=self.quality)
                
                return thumbnail_path
                
        except Exception as e:
            logger.error(f"生成缩略图失败: {photo_path}, 错误: {e}")
            return None
    
    def _generate_thumbnail_name(self, photo_id: int, original_name: str) -> str:
        """生成缩略图文件名"""
        name_without_ext = original_name.rsplit('.', 1)[0]
        return f"{photo_id}_{name_without_ext}_thumb.jpg"
    
    def _get_thumbnail_directory(self, photo_path: str) -> str:
        """获取缩略图目录（与原始照片目录对应）"""
        # 从原始照片路径提取年月日
        relative_path = os.path.relpath(photo_path, self.base_path)
        path_parts = relative_path.split(os.sep)
        
        if len(path_parts) >= 4:  # originals/year/month/day/filename
            year, month, day = path_parts[1], path_parts[2], path_parts[3]
            return os.path.join(self.thumbnails_path, year, month, day)
        else:
            return self.thumbnails_path
```

### 4.2 空间管理

#### 4.2.1 存储空间监控
```python
class StorageMonitor:
    """存储空间监控器"""
    
    def __init__(self, base_path: str):
        self.base_path = base_path
        
    def get_storage_info(self) -> dict:
        """
        获取存储信息
        
        :return: 存储信息字典
        """
        total_size = self._get_directory_size(self.base_path)
        originals_size = self._get_directory_size(os.path.join(self.base_path, 'originals'))
        thumbnails_size = self._get_directory_size(os.path.join(self.base_path, 'thumbnails'))
        temp_size = self._get_directory_size(os.path.join(self.base_path, 'temp'))
        backups_size = self._get_directory_size(os.path.join(self.base_path, 'backups'))
        
        # 获取磁盘可用空间
        disk_info = self._get_disk_info()
        
        return {
            'total_size': total_size,
            'originals_size': originals_size,
            'thumbnails_size': thumbnails_size,
            'temp_size': temp_size,
            'backups_size': backups_size,
            'disk_free': disk_info['free'],
            'disk_total': disk_info['total']
        }
    
    def _get_directory_size(self, path: str) -> int:
        """获取目录大小"""
        total_size = 0
        try:
            for dirpath, dirnames, filenames in os.walk(path):
                for filename in filenames:
                    filepath = os.path.join(dirpath, filename)
                    try:
                        total_size += os.path.getsize(filepath)
                    except OSError:
                        pass
        except FileNotFoundError:
            pass
        return total_size
    
    def _get_disk_info(self) -> dict:
        """获取磁盘信息"""
        stat = os.statvfs(self.base_path)
        free_bytes = stat.f_bavail * stat.f_frsize
        total_bytes = stat.f_blocks * stat.f_frsize
        return {
            'free': free_bytes,
            'total': total_bytes
        }
```

#### 4.2.2 临时文件清理
```python
class TempFileCleaner:
    """临时文件清理器"""
    
    def __init__(self, temp_path: str, max_age_hours: int = 24):
        self.temp_path = temp_path
        self.max_age_hours = max_age_hours
        
    def clean_temp_files(self) -> dict:
        """
        清理临时文件
        
        :return: 清理结果
        """
        cleaned_files = []
        cleaned_size = 0
        current_time = time.time()
        
        try:
            for dirpath, dirnames, filenames in os.walk(self.temp_path):
                for filename in filenames:
                    filepath = os.path.join(dirpath, filename)
                    
                    try:
                        # 检查文件修改时间
                        file_mtime = os.path.getmtime(filepath)
                        age_hours = (current_time - file_mtime) / 3600
                        
                        if age_hours > self.max_age_hours:
                            file_size = os.path.getsize(filepath)
                            os.remove(filepath)
                            cleaned_files.append(filepath)
                            cleaned_size += file_size
                            
                    except OSError as e:
                        logger.warning(f"清理临时文件失败: {filepath}, 错误: {e}")
                        
        except Exception as e:
            logger.error(f"清理临时文件过程出错: {e}")
            
        return {
            'cleaned_files_count': len(cleaned_files),
            'cleaned_size': cleaned_size,
            'cleaned_files': cleaned_files
        }
```

### 4.3 备份恢复管理

#### 4.3.1 备份策略
```python
class BackupManager:
    """备份管理器"""
    
    def __init__(self, base_path: str, backup_path: str):
        self.base_path = base_path
        self.backup_path = backup_path
        
    def create_backup(self, backup_type: str = 'incremental') -> str:
        """
        创建备份
        
        :param backup_type: 备份类型 (full/incremental)
        :return: 备份文件路径
        """
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        if backup_type == 'full':
            backup_name = f"full_backup_{timestamp}.zip"
        else:
            backup_name = f"incremental_backup_{timestamp}.zip"
            
        backup_path = os.path.join(self.backup_path, backup_name)
        
        try:
            # 创建备份目录
            os.makedirs(os.path.dirname(backup_path), exist_ok=True)
            
            # 创建ZIP备份
            with zipfile.ZipFile(backup_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                self._add_to_zip(zipf, self.base_path, '')
                
            logger.info(f"备份创建成功: {backup_path}")
            return backup_path
            
        except Exception as e:
            logger.error(f"备份创建失败: {e}")
            return None
    
    def _add_to_zip(self, zipf: zipfile.ZipFile, source_dir: str, archive_path: str):
        """递归添加文件到ZIP"""
        for item in os.listdir(source_dir):
            source_path = os.path.join(source_dir, item)
            
            if os.path.isdir(source_path):
                # 递归处理目录
                self._add_to_zip(zipf, source_path, os.path.join(archive_path, item))
            else:
                # 添加文件
                zipf.write(source_path, os.path.join(archive_path, item))
```

#### 4.3.2 恢复管理
```python
class RestoreManager:
    """恢复管理器"""
    
    def __init__(self, base_path: str, backup_path: str):
        self.base_path = base_path
        self.backup_path = backup_path
        
    def restore_backup(self, backup_file: str) -> bool:
        """
        从备份恢复
        
        :param backup_file: 备份文件路径
        :return: 是否成功
        """
        try:
            # 验证备份文件
            if not os.path.exists(backup_file):
                logger.error(f"备份文件不存在: {backup_file}")
                return False
            
            # 创建临时恢复目录
            temp_restore_path = os.path.join(self.base_path, 'temp_restore')
            os.makedirs(temp_restore_path, exist_ok=True)
            
            # 解压备份文件
            with zipfile.ZipFile(backup_file, 'r') as zipf:
                zipf.extractall(temp_restore_path)
            
            # 验证恢复的文件
            if self._validate_restore(temp_restore_path):
                # 执行恢复
                self._perform_restore(temp_restore_path)
                logger.info(f"备份恢复成功: {backup_file}")
                return True
            else:
                logger.error("备份文件验证失败")
                return False
                
        except Exception as e:
            logger.error(f"备份恢复失败: {e}")
            return False
        finally:
            # 清理临时文件
            if os.path.exists(temp_restore_path):
                shutil.rmtree(temp_restore_path)
    
    def _validate_restore(self, restore_path: str) -> bool:
        """验证恢复文件"""
        # 检查必要文件是否存在
        required_files = ['photos.db']
        for filename in required_files:
            if not os.path.exists(os.path.join(restore_path, filename)):
                return False
        return True
    
    def _perform_restore(self, restore_path: str):
        """执行恢复"""
        # 停止相关服务（如果有）
        
        # 备份当前文件
        self._backup_current_files()
        
        # 复制恢复文件
        for item in os.listdir(restore_path):
            source = os.path.join(restore_path, item)
            dest = os.path.join(self.base_path, item)
            
            if os.path.isdir(source):
                if os.path.exists(dest):
                    shutil.rmtree(dest)
                shutil.copytree(source, dest)
            else:
                shutil.copy2(source, dest)
        
        # 重启相关服务（如果有）
    
    def _backup_current_files(self):
        """备份当前文件"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_dir = os.path.join(self.base_path, f'pre_restore_backup_{timestamp}')
        os.makedirs(backup_dir, exist_ok=True)
        
        # 备份主要文件
        files_to_backup = ['photos.db']
        for filename in files_to_backup:
            filepath = os.path.join(self.base_path, filename)
            if os.path.exists(filepath):
                shutil.copy2(filepath, os.path.join(backup_dir, filename))
```

## 五、数据库管理

### 5.1 数据库存储优化

#### 5.1.1 SQLite配置优化
```python
class DatabaseManager:
    """数据库管理器"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.connection = None
        
    def get_connection(self):
        """获取数据库连接"""
        if self.connection is None:
            self.connection = sqlite3.connect(
                self.db_path,
                timeout=30,
                isolation_level=None  # 自动提交模式
            )
            self._optimize_connection()
        return self.connection
    
    def _optimize_connection(self):
        """优化数据库连接"""
        cursor = self.connection.cursor()
        
        # 启用WAL模式，提高并发性能
        cursor.execute('PRAGMA journal_mode=WAL')
        
        # 设置同步模式为NORMAL，平衡性能和安全性
        cursor.execute('PRAGMA synchronous=NORMAL')
        
        # 设置缓存大小
        cursor.execute('PRAGMA cache_size=-64000')  # 64MB缓存
        
        # 启用外键约束
        cursor.execute('PRAGMA foreign_keys=ON')
        
        cursor.close()
```

#### 5.1.2 数据库备份恢复
```python
class DatabaseBackupManager:
    """数据库备份管理器"""
    
    def __init__(self, db_path: str, backup_path: str):
        self.db_path = db_path
        self.backup_path = backup_path
        
    def backup_database(self) -> str:
        """
        备份数据库
        
        :return: 备份文件路径
        """
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_filename = f"photos_db_backup_{timestamp}.db"
        backup_path = os.path.join(self.backup_path, backup_filename)
        
        try:
            # 使用SQLite的VACUUM INTO命令进行备份
            conn = sqlite3.connect(self.db_path)
            conn.execute(f"VACUUM INTO '{backup_path}'")
            conn.close()
            
            logger.info(f"数据库备份成功: {backup_path}")
            return backup_path
            
        except Exception as e:
            logger.error(f"数据库备份失败: {e}")
            return None
    
    def restore_database(self, backup_path: str) -> bool:
        """
        恢复数据库
        
        :param backup_path: 备份文件路径
        :return: 是否成功
        """
        try:
            # 验证备份文件
            if not os.path.exists(backup_path):
                logger.error(f"备份文件不存在: {backup_path}")
                return False
            
            # 创建恢复备份
            restore_backup = f"{self.db_path}.restore_backup"
            if os.path.exists(self.db_path):
                shutil.copy2(self.db_path, restore_backup)
            
            # 复制备份文件
            shutil.copy2(backup_path, self.db_path)
            
            logger.info(f"数据库恢复成功: {backup_path}")
            return True
            
        except Exception as e:
            logger.error(f"数据库恢复失败: {e}")
            # 恢复原始文件
            if os.path.exists(restore_backup):
                shutil.copy2(restore_backup, self.db_path)
            return False
```

## 六、API接口设计

### 6.1 存储管理接口

#### 6.1.1 存储信息查询
```python
@router.get("/storage/info")
async def get_storage_info() -> dict:
    """
    获取存储信息
    
    :return: 存储信息
    """
```

#### 6.1.2 存储空间清理
```python
@router.post("/storage/cleanup")
async def cleanup_storage(cleanup_type: str = "temp") -> dict:
    """
    清理存储空间
    
    :param cleanup_type: 清理类型 (temp/cache/all)
    :return: 清理结果
    """
```

#### 6.1.3 备份创建
```python
@router.post("/storage/backup")
async def create_backup(backup_type: str = "incremental") -> dict:
    """
    创建备份
    
    :param backup_type: 备份类型 (full/incremental)
    :return: 备份结果
    """
```

#### 6.1.4 备份恢复
```python
@router.post("/storage/restore")
async def restore_backup(backup_file: str) -> dict:
    """
    恢复备份
    
    :param backup_file: 备份文件路径
    :return: 恢复结果
    """
```

### 6.2 文件管理接口

#### 6.2.1 文件上传
```python
@router.post("/files/upload")
async def upload_file(file: UploadFile) -> dict:
    """
    上传文件
    
    :param file: 上传的文件
    :return: 上传结果
    """
```

#### 6.2.2 文件下载
```python
@router.get("/files/download/{file_id}")
async def download_file(file_id: int) -> FileResponse:
    """
    下载文件
    
    :param file_id: 文件ID
    :return: 文件响应
    """
```

#### 6.2.3 文件删除
```python
@router.delete("/files/{file_id}")
async def delete_file(file_id: int) -> dict:
    """
    删除文件
    
    :param file_id: 文件ID
    :return: 删除结果
    """
```

## 七、配置管理

### 7.1 存储配置

#### 7.1.1 基本存储配置
```json
{
  "storage": {
    "base_path": "./photos_storage",
    "originals_path": "originals",
    "thumbnails_path": "thumbnails",
    "temp_path": "temp",
    "backups_path": "backups",
    "max_file_size": 52428800,
    "thumbnail_size": 300,
    "thumbnail_quality": 85,
    "max_concurrent": 2
  }
}
```

#### 7.1.2 备份配置
```json
{
  "backup": {
    "enabled": true,
    "schedule": "daily",
    "retention_days": 30,
    "compression_level": 6,
    "backup_types": ["database", "files"]
  }
}
```

#### 7.1.3 清理配置
```json
{
  "cleanup": {
    "temp_file_max_age": 24,
    "cache_max_age": 7,
    "auto_cleanup": true,
    "cleanup_schedule": "daily"
  }
}
```

## 八、监控与日志

### 8.1 存储监控

#### 8.1.1 存储指标
- **存储空间使用**：各目录占用空间统计
- **文件数量统计**：各类文件数量变化
- **存储性能指标**：读写速度、I/O操作统计
- **备份状态监控**：备份成功率、备份大小变化

#### 8.1.2 存储告警
- **空间不足告警**：存储空间使用率超过阈值
- **文件损坏告警**：检测到文件完整性问题
- **备份失败告警**：备份操作失败
- **性能下降告警**：存储性能异常

### 8.2 日志管理

#### 8.2.1 存储操作日志
- **文件操作日志**：上传、下载、删除操作记录
- **存储管理日志**：清理、备份、恢复操作记录
- **性能日志**：存储操作性能统计
- **错误日志**：存储操作错误记录

#### 8.2.2 日志分析
- **存储趋势分析**：存储空间使用趋势
- **操作模式分析**：用户存储操作模式
- **性能瓶颈分析**：存储性能问题分析
- **错误模式分析**：存储错误类型统计

## 九、测试策略

### 9.1 功能测试

#### 9.1.1 存储功能测试
- **文件存储测试**：各种格式文件的存储
- **目录结构测试**：目录自动创建和组织
- **文件命名测试**：文件名生成规则验证
- **缩略图生成测试**：缩略图质量和尺寸

#### 9.1.2 备份恢复测试
- **备份创建测试**：备份文件生成和完整性
- **恢复测试**：备份文件恢复的正确性
- **增量备份测试**：增量备份的准确性
- **压缩测试**：备份文件压缩效果

### 9.2 性能测试

#### 9.2.1 存储性能测试
- **文件读写测试**：文件操作响应时间
- **并发访问测试**：多用户同时访问性能
- **大文件处理测试**：大文件上传下载性能
- **存储空间测试**：大量文件存储性能

#### 9.2.2 备份性能测试
- **备份速度测试**：备份操作耗时
- **恢复速度测试**：恢复操作耗时
- **压缩性能测试**：压缩算法性能
- **存储效率测试**：备份文件大小控制

## 十、部署与运维

### 10.1 部署架构

#### 10.1.1 单机部署
存储管理模块直接使用本地文件系统，无需额外配置。数据库文件存储在指定目录，文件按年月日组织。

**部署特点**：
- 无需额外服务
- 配置简单
- 维护方便

#### 10.1.2 网络部署
在网络环境中，存储管理模块需要考虑网络文件系统的访问权限和性能优化。

### 10.2 运维管理

#### 10.2.1 日常维护
- **存储空间监控**：定期检查存储使用情况
- **文件完整性检查**：定期验证文件完整性
- **备份验证**：定期测试备份恢复功能
- **性能监控**：监控存储操作性能

#### 10.2.2 故障处理
- **存储空间不足**：清理临时文件，删除无用数据
- **文件损坏**：从备份恢复，验证文件完整性
- **性能问题**：优化存储配置，调整缓存策略
- **备份失败**：检查备份配置，验证存储权限

## 十一、总结

存储管理模块作为家庭照片系统的存储核心，提供了完整的文件存储、备份恢复和空间管理功能。

**设计特点**：
- 存储结构清晰，按年月日自动组织
- 支持多种备份策略，确保数据安全
- 空间管理智能，自动清理临时文件
- 配置简单，易于维护和扩展

**技术亮点**：
- 高效的文件存储策略

---

**文档版本**：V2.0
**最后更新**：2025年9月17日
**文档状态**：草稿

**更新说明**：
- 更新技术栈描述，反映实际使用的存储技术
- 完善存储目录结构，基于实际实现
- 更新API接口数量，从8个增加到实际数量
- 补充备份恢复和空间管理的实现细节
- 增加性能监控和故障处理说明
- 更新配置管理和维护策略
- 完善的备份恢复机制
- 智能的空间管理功能
- 可靠的数据库管理

**适用场景**：
- 家庭使用，支持大量照片存储
- 提供数据备份和恢复功能
- 支持存储空间监控和管理
- 便于数据迁移和维护

通过遵循本设计文档，开发团队可以快速实现存储管理模块的功能，为整个系统的稳定运行提供坚实的基础。模块的可靠性和易用性，将确保用户照片数据的安全存储和高效访问。
