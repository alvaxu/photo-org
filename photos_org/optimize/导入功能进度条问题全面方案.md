好的！让我全面总结一下统一的进度条方案。

## �� 统一进度条方案完整总结

### **1. 核心设计原则**
- **统一API**：所有导入都使用 `/import/upload` API
- **统一处理**：所有导入都使用后台任务 + 真实进度条
- **统一体验**：不管文件多少，用户体验完全一致
- **统一轮询**：所有情况都使用0.5秒轮询频率

### **2. 技术实现方案**

#### **后端修改：**

**修改 `/import/upload` API：**
```python
@router.post("/upload")
async def upload_photos(
    files: List[UploadFile] = File(...),
    background_tasks: BackgroundTasks = None,
    db: Session = Depends(get_db)
):
    # 1. 文件数量检查
    if len(files) > settings.import_config.max_upload_files:
        raise HTTPException(status_code=400, detail=f"单次最多上传{settings.import_config.max_upload_files}个文件")
    
    # 2. 统一使用后台任务处理
    task_id = str(uuid.uuid4())
    background_tasks.add_task(process_photos_batch_with_status, files, db, task_id)
    
    # 3. 立即返回任务ID
    return JSONResponse(
        status_code=202,
        content={
            "success": True,
            "message": f"已提交{len(files)}个文件进行后台处理",
            "data": {
                "task_id": task_id,
                "total_files": len(files),
                "status": "processing"
            }
        }
    )
```

**修改 `process_photos_batch_with_status` 函数：**
```python
async def process_photos_batch_with_status(files: List[UploadFile], db, task_id: str):
    # 1. 初始化任务状态
    task_status[task_id] = {
        "status": "processing",
        "total_files": len(files),
        "processed_files": 0,
        "imported_count": 0,
        "skipped_count": 0,
        "failed_count": 0,
        "failed_files": [],
        "progress_percentage": 0,
        "start_time": datetime.now().isoformat(),
        "end_time": None,
        "error": None
    }
    
    # 2. 处理每个文件
    for i, file in enumerate(files):
        # 处理文件...
        
        # 3. 更新进度（每处理一个文件就+1，不管结果）
        task_status[task_id]["processed_files"] = i + 1
        task_status[task_id]["progress_percentage"] = int((i + 1) / len(files) * 100)
    
    # 4. 标记完成
    task_status[task_id]["status"] = "completed"
    task_status[task_id]["end_time"] = datetime.now().isoformat()
```

#### **前端修改：**

**统一导入函数：**
```javascript
async function startFileImport() {
    // 1. 显示进度条
    elements.importProgress.classList.remove('d-none');
    elements.importProgressBar.style.width = '0%';
    elements.importStatus.textContent = `正在准备处理 ${files.length} 个文件...`;
    
    // 2. 调用统一API
    const response = await fetch(`${CONFIG.API_BASE_URL}/import/upload`, {
        method: 'POST',
        body: formData
    });
    
    // 3. 获取任务ID
    const data = await response.json();
    const taskId = data.data.task_id;
    
    // 4. 立即开始监控
    monitorImportProgress(taskId, files.length);
}

async function startFolderImport() {
    // 相同的逻辑，只是文件来源不同
    // ... 处理文件夹文件 ...
    
    // 调用相同的API和监控逻辑
    const response = await fetch(`${CONFIG.API_BASE_URL}/import/upload`, {
        method: 'POST',
        body: formData
    });
    
    const data = await response.json();
    const taskId = data.data.task_id;
    
    monitorImportProgress(taskId, imageFiles.length);
}
```

**统一进度监控：**
```javascript
function monitorImportProgress(taskId, totalFiles) {
    const progressInterval = setInterval(async () => {
        try {
            const response = await fetch(`${CONFIG.API_BASE_URL}/scan-status/${taskId}`);
            const statusData = await response.json();
            
            // 更新进度条
            const progress = statusData.progress_percentage || 0;
            elements.importProgressBar.style.width = `${progress}%`;
            elements.importStatus.textContent = `正在处理: ${statusData.processed_files}/${totalFiles} (${progress}%) - 已导入: ${statusData.imported_count}, 跳过: ${statusData.skipped_count}, 失败: ${statusData.failed_count}`;
            
            // 检查是否完成
            if (statusData.status === 'completed') {
                clearInterval(progressInterval);
                showImportDetails(statusData);
                // 关闭模态框，重新加载照片列表
            } else if (statusData.status === 'failed') {
                clearInterval(progressInterval);
                showError(`导入失败：${statusData.error}`);
            }
        } catch (error) {
            console.error('进度监控失败:', error);
        }
    }, 500); // 每0.5秒检查一次
}
```

### **3. 关键特性**

#### **进度计算逻辑：**
- **分母**：总文件数量
- **分子**：已处理的文件数量（每处理一个文件就+1）
- **包含**：成功、跳过、失败的文件都计入进度
- **计算**：`(已处理文件数 / 总文件数) * 100%`

#### **轮询策略：**
- **频率**：0.5秒/次
- **开始时机**：API调用后立即开始
- **结束条件**：任务完成或失败
- **超时保护**：最多轮询120次（1分钟）

#### **用户体验：**
- **统一界面**：所有导入都使用相同的进度条UI
- **实时反馈**：进度条和状态文本实时更新
- **详细统计**：显示导入、跳过、失败的数量
- **结果展示**：处理完成后显示详细结果

### **4. 实现优势**

**技术优势：**
- ✅ 代码统一，维护简单
- ✅ 功能完整，无缺失
- ✅ 性能优化，后台处理
- ✅ 错误处理统一

**用户体验优势：**
- ✅ 界面一致，操作统一
- ✅ 进度反馈真实准确
- ✅ 结果展示详细完整
- ✅ 错误提示清晰明确

### **5. 实现步骤**

1. **修改后端API**：统一使用后台任务
2. **修改前端调用**：统一使用进度监控
3. **测试验证**：确保功能完整
4. **优化调整**：根据测试结果微调
